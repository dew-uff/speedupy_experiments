EPR-simple
==========

A Simple event-by-event simulation of the EPR experiment

How it works:
------------
The simulation consists of a Source, generating particle pairs, to be analyzed at 2 Detection stations. The maths of the model can be summarized as:  

        λ = {e, p, s},  e ∈ [0..2π), s = {1/2, 1}
        p =  ½ sin²t, t ∈ [0..π/2)
        e' = e + 2πs
        A(a,λ) = sign(-1ⁿ cos n(a − e)) if |cos n(a − e)| > p
        B(b,λ) = sign(-1ⁿ cos n(b − e')) if |cos n(b − e')| > p
        where n = 2s
        
        Alternatively,  p = tᵏ, t ∈ [0..π/4), k=π/2 also works well.

1) The Source, and Particles:

        Usage:
	         python source.py <duration in seconds> <spin> 

Generates two files containing the emitted particles, one for each arm of the experiment.
Each file is a gzipped binary numpy array file containing 3 columns with the rows representing the 
parameters of a single emitted particle. The files are named `SrcLeft.npy.gz` and `SrcRight.npy.gz`.
The source has a single parameter `spin (s)` which determines the type of particles produced. For spin 1/2 particles such as electrons, s=1/2 for photons s=1.

A particle pair is generated as follows:  

    `e` - an angle common to both particles selected randomly each time from the range [0, 2π)
    `p` - a property common to both particles selected randomly according to a prescribed probability distribution
    
The left particle is the tuple `(e, p, n)`
The right particle is the tuple `(e + 2πs, p, n)`

2) The Detection Stations:  

        Usage:
	         python station.py <ArmSrcFile> [seting1,setting2,setting3,...]

Reads one of the source files generated by `source.py` and generates another file
containing the outcomes. The same program is run on both arms just with a different
source file. The input parameters are:  

        `ArmSrcFile`: one of `SrcLeft.npy.gz` or `SrcRight.npy.gz`
        `settings sequence`: optional comma separated list of settings to randomly chose between
           for example 0,22.5,45,67.5 (no spaces between). if no sequence is provided, a sequence of
           33 evenly spaced angles between 0 and 2π will be generated and used.

The output file will be named `Alice.npy.gz` if provided source file was `SrcLeft.npy.gz` and `Bob.npy.gz` if the provided file was `SrcRight.npy.gz`. The format of the output files are also gzipped binary numpy array files containing 2 columns. The detection at each station proceeds as follows:  

    - A transformed value `C` is calculated using the particle properties and 
      the detector setting `x` as `C = -1ⁿ cos n(x − e)`. The sign and magnitude of this function is used 
      to determine which channel the particle will be detected at; `+1` or `-1`
    - The setting `x` and the outcomes are registered locally. Each station is not aware of and 
      uses no information from or about the other station. In fact, the `SrcLeft.npy.gz` and `SrcRight.npy.gz`
      can be copied onto separate computers disconnected from the network, and a copy of the station program run
      on those computers to generate the output files
      

Statistical Analysis:
--------------------    

        Usage: 
	         analyse.py <spin>

This program performs the statistical analysis of the results following the standard practice of analyzing experimental correlations for EPRB experiments. The statistics are calculated as follows. The angle difference between Alice and Bob's setting is calculated using the first column of their respective output arrays, converted to degrees and rounded to the nearest degree. For each angle in the range [0, 2π), we collect all instances where that angle difference was observed. Then we count the number of occurences of (++), (+-), (-+), (--) coincidences between the outcomes of Alice and Bob:  

    - N⁺⁺ : Number of pairs where Both Alice and Bob measured +1
    - N⁻⁻ : ...  Both Alice and Bob measured -1
    - N⁺⁻ : ...  Alice got +1 and Bob got -1
    - N⁻⁺ : ...  Alice got -1 and Bob got +1
    - nA⁺ : ...  Alice got +1
    - nB⁺ : ...  Bob got +1

From these counts, we calcualte the individual probabilities:  

    Pⁱʲ = Nⁱʲ/(N⁺⁺ + N⁻⁻ + N⁺⁻ + N⁻⁺), ij ∈ {++, --, +-, -+}
    
The probability for single sided results Aⁱ and Bⁱ are calculated:  

    pAⁱ = nA/(nA⁺ + nA-), pBⁱ = nB/(nB⁺ + nB-), i∈ {+,-}
    
From these probabilities we can calcualte the Expectation value:  

    E(a,b) = P⁺⁺ + P⁻⁻ - P⁺⁻ - P⁻⁺   

The results are then plotted for every angle pair (a,b) in the range [0, 2π). A sample plot after a 60 second simulation is shown in the file `analysis.png`. The output for the Bell-test angles (0, 22.5, 45, 67.5) are shown below:  


    Expectation values
      Settings       N_ab   <AB>_sim    <AB>_qm StdErr_sim
       0, 22.5       1534     -0.934     -0.924      0.024
       0, 67.5       1364     -0.391     -0.383      0.011
      45, 22.5       1510     -0.926     -0.924      0.024
      45, 67.5       1532     -0.943     -0.924      0.024

	Same Angle <AB> = -1.00
	Oppo Angle <AB> = +1.00
	CHSH: <= 2.0, Sim: 2.410, QM: 2.389
    


Notes:
-----

Each particle is treated separately from the source to detection in a completely local and realistic manner. In fact the whole simulation can be performed on separate computers as illustrated above, with the analysis performed on a fourth computer. A typical run of a "separate computer" version of the simulation would look like the following:  

    Computer 1: python source.py 60 0.5  
        -Copy SrcLeft.npy.gz to computer 2  
        -Copy SrcRight.npy.gz to computer 3  
    Computer 2: python station.py SrcLeft.npy.gz  
    Computer 3: python station.py SrcRight.npy.gz  
        -Copy Alice.npy.gz from computer 2 to computer 4  
        -Copy Bob.npy.gz from computer 3 to computer 4  
    Computer 4: python analyse.py 0.5  



Each detection station behaves exactly the same as the other. Swapping the particles and sending them the opposite way does not change the results.

The model reproduces *almost* exactly the QM correlation for both electrons and photons
and matches experimental data very well. See http://arxiv.org/pdf/quant-ph/0606122.pdf (Fig 1).

Obviously the model would "violate" the CHSH inequality in the same way as QM predictions and experimental expectation values. More careful study of the inequalities actually reveal that such violation by QM, experiments, and simulations like this are only apparent.

To run the simulation yourself, start by running the source for a shorter time period, say 10s. This version of the simulation uses all the CPU cores available on your computer to run faster. Longer runs may require a lot of memory. Running the source for 10 seconds will produce files that can be processed at each station for roughly the same amount of time. On any Linux system, you need to have `matplotlib` installed for the plotting, as well as `numpy`. I haven't tested on Windows but you probably want a "batteries-included" python distribution such as "Python xy" http://code.google.com/p/pythonxy/. 
